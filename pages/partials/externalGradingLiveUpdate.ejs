<% if (question.grading_method == 'External') { %>
<script>
  $(function() {
    var socket = io('/external-grading');
    var variantId = '<%= variant.id %>';
    var variantToken = '<%= variantToken %>';
    var urlPrefix = '<%= urlPrefix %>';
    var questionContext = '<%= question_context %>';
    var csrfToken = '<%= __csrf_token %>';

    // Render initial grading states into the DOM
    $('[id^=submission-]').each(function(index, elem) {
      var status = $(elem).data('grading-job-status');
      var submissionId = $(elem).attr('id').replace('submission-', '');
      updateStatus(submissionId, status);
    });

    socket.emit('init', {variant_id: variantId, variant_token: variantToken}, function(msg) {
      handleStatusChange(msg.submissions);
    });

    socket.on('submission:new', function(msg) {
      handleNewSubmission(msg.submission);
    });

    socket.on('submission:status', function(msg) {
      handleStatusChange(msg.submissions);
    });

    function handleNewSubmission(submission) {
      var submissionId = 'submission-' + submission.id;
      // We need to create a container for this question
      $('#question-submissions').prepend('<div id="' + submissionId + '" data-new="true"></div>');
      fetchResults(submission.id, function() {
        // Let's collapse all past submissions once the new one renders
        $('#question-submissions .question-submission').each(function () {
          var thisSubmissionId = $(this).attr('id');
          if (thisSubmissionId != submissionId) {
            $(this).find('.collapse').collapse('hide');
          }
        });
        // Scroll new result into view if the submissions panel isn't in view
        var viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        var submissionsOffset = $('#question-submissions').offset();
        var windowScrollTop = $(window).scrollTop();
        if (windowScrollTop + viewportHeight < submissionsOffset.top) {
          setTimeout(function() {
            $('html, body').animate({
              scrollTop: $('#' + submissionId).offset().top - 50,
            });
          }, 0);
        }

        // Sync status into the DOM
        updateStatus(submission);
      });
    }

    function handleStatusChange(submissions) {
      submissions.forEach(function(submission) {
        // Always update results
        updateStatus(submission);

        if (submission.grading_job_status == 'graded') {
          // Check if this state is reflected in the DOM; it's possible this is
          // just a message from the initial data sync and that we already have
          // results in the DOM.
          var status = $('#submission-' + submission.id).data('grading-job-status');
          var gradingJobId = $('#submission-' + submission.id).data('grading-job-id');

          // Ignore jobs that we already have results for, but allow results
          // from more recent grading jobs to replace the existing ones.
          if (status != 'graded' || gradingJobId != submission.grading_job_id) {
            // Let's get results for this job!
            fetchResults(submission.id);
          }
        }
      });
    }

    function fadeAndReplace(selector, newContent) {
      var target = $(selector);
      target.fadeOut('fast', function() {
        target.replaceWith(function() {
          return $(newContent).hide().fadeIn('fast');
        });
      });
    }

    function fetchResults(submissionId, callback) {
      socket.emit('getResults', {
        variant_id: variantId,
        variant_token: variantToken,
        submission_id: submissionId,
        url_prefix: urlPrefix,
        question_context: questionContext,
        csrf_token: csrfToken
      }, function(msg) {
        if (msg.submissionPanel) {
          var target = $('#submission-' + submissionId);
          if (target.data('new') == true) {
            // The panel hasn't actually had content rendered yet.
            // Skip the fadeout and render immediately
            target.replaceWith(function() {
              return $(msg.submissionPanel).hide().fadeIn('fast');
            });
          } else {
            fadeAndReplace('#submission-' + submissionId, msg.submissionPanel);
          }
        }
        if (msg.questionScorePanel) {
          fadeAndReplace('#question-score-panel', msg.questionScorePanel);
        }
        if (msg.assessmentScorePanel) {
          fadeAndReplace('#assessment-score-panel', msg.assessmentScorePanel);
        }
        if (msg.questionPanelFooter) {
          fadeAndReplace('#question-panel-footer', msg.questionPanelFooter);
        }

        if (callback) {
          callback();
        }
      });
    }

    function updateStatus(submission) {
      var display = $('#grading-status-' + submission.id);
      var label;
      var spinner = '<i class="fa fa-sync fa-spin fa-fw"></i>';
      switch (submission.grading_job_status) {
        case 'requested':
          label = 'Grading requested ' + spinner;
          break;
        case 'queued':
          label = 'Queued for grading ' + spinner;
          break;
        case 'grading':
          label = 'Grading in progress ' + spinner;
          break;
        case 'graded':
          label = 'Graded!'
          break;
        default:
          label = 'UNKNOWN STATUS';
          break;
      }
      display.html(label);
    }
  });
</script>
<% } %>
