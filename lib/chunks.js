// @ts-check
const path = require('path');

const { sqlDb, sqlLoader } = require('@prairielearn/prairielib');

const sql = sqlLoader.loadSqlEquiv(__filename);

/** @typedef {"elements" | "clientFilesCourse" | "serverFilesCourse" | "clientFilesCourseInstance" | "clientFilesAssessment" | "question"} ChunkType */

/**
 * @typedef {Object} ChunkMetadata
 * @property {ChunkType} type The type of this particular chunk
 * @property {string} [questionName] The question name (QID) of a chunk, if applicable
 * @property {string} [questionUuid] The question UUID of a chunk, if applicable
 * @property {string} [courseInstanceName] The course instance name of a chunk, if applicable
 * @property {string} [courseInstanceUuid] The course instance UUID of a chunk, if applicable
 * @property {string} [assessmentName] The assessment name (TID) of a chunk, if applicable
 * @property {string} [assessmentUuid] the Assessment UUID of a chunk, if applicable
 */

/**
 * @typedef {Object} CourseInstanceChunks 
 * @property {boolean} clientFilesCourseInstance
 * @property {Set<string>} assessments
 */

/**
 * @typedef {Object} CourseChunks
 * @property {boolean} elements
 * @property {boolean} clientFilesCourse
 * @property {boolean} serverFilesCourse
 * @property {Set<string>} questions
 * @property {{ [id: string]: CourseInstanceChunks }} courseInstances
 */

/**
 * Given a list of files that have changed (such as that produced by
 * `git diff --name-only`), returns a data structure describing the chunks
 * that need to be generated.
 * 
 * @param {string[]} changedFiles A list of files that changed in a given sync.
 * @param {object} course The "full course" that was loaded from disk, as generated by `course-db.js#loadFullCourse`.
 * @returns {CourseChunks}
 */
module.exports.identifyChunksFromChangedFiles = (changedFiles, course) => {
    /** @type {CourseChunks} */
    const courseChunks = {
        elements: false,
        clientFilesCourse: false,
        serverFilesCourse: false,
        courseInstances: {},
        questions: new Set(),
    };

    changedFiles.forEach(changedFile => {
        if (changedFile.startsWith('elements/')) {
            courseChunks.elements = true;
        }
        if (changedFile.startsWith('serverFilesCourse/')) {
            courseChunks.serverFilesCourse = true;
        }
        if (changedFile.startsWith('clientFilesCourse/')) {
            courseChunks.clientFilesCourse = true;
        }
        if (changedFile.startsWith('questions/')) {
            // Here's where things get interesting. Questions can be nested in
            // directories, so we need to figure out which of the potentially
            // deeply-nested directories is the root of a particular question.
            const pathComponents = changedFile.split(path.sep).slice(1);
            // Progressively join more and more path components until we get
            // something that corresponds to an actual question
            let questionId = null;
            for (let i = 1; i < pathComponents.length; i++) {
                const candidateQuestionId = path.join(...pathComponents.slice(0, i));
                if (course.questionDB[candidateQuestionId]) {
                    questionId = candidateQuestionId;
                    break;
                }
            }
            if (questionId) {
                // This chunk corresponds to a question!
                courseChunks.questions.add(questionId);
            }
        }
        if (changedFile.startsWith('courseInstances/')) {
            // This could be one of two things: `clientFilesCourseInstance` or
            // `clientFileAssessment`.

            const pathComponents = changedFile.split(path.sep).slice(1);

            const clientFilesCourseInstanceIndex = pathComponents.indexOf('clientFilesCourseInstance');
            const assessmentsIndex = pathComponents.indexOf('assessments');
            const clientFilesAssessmentIndex = pathComponents.indexOf('clientFilesAssessment');

            if (clientFilesCourseInstanceIndex >= 0) {
                // Let's validate that the preceeding path components correspond
                // to an actual course instance
                const courseInstanceId = path.join(...pathComponents.slice(0, clientFilesCourseInstanceIndex));
                if (course.courseInstanceDB[courseInstanceId]) {
                    if (!courseChunks.courseInstances[courseInstanceId]) {
                        courseChunks.courseInstances[courseInstanceId] = {
                            assessments: new Set(),
                            clientFilesCourseInstance: true,
                        };
                    }
                    courseChunks.courseInstances[courseInstanceId].clientFilesCourseInstance = true;
                    return;
                }
            }

            // Important: fall through to account for weird things like people putting
            // `clientFilesCourseInstance` directories inside of `clientFileAssessment`
            // for some strange reason.
            if (
                assessmentsIndex >= 0 &&
                clientFilesAssessmentIndex >= 0 &&
                clientFilesAssessmentIndex > assessmentsIndex
            ) {
                // We probably care about this file - let's validate that by
                // splitting up the path into chunks that hopefully correspond
                // to course instance IDs and assessment IDs.
                const courseInstanceId = path.join(...pathComponents.slice(0, assessmentsIndex));
                const assessmentId = path.join(...pathComponents.slice(assessmentsIndex + 1, clientFilesAssessmentIndex));

                if (
                    course.courseInstanceDB[courseInstanceId] &&
                    course.courseInstanceDB[courseInstanceId].assessmentDB[assessmentId]
                ) {
                    // This corresponds to something that we need to
                    // create/update a chunk for!
                    if (!courseChunks.courseInstances[courseInstanceId]) {
                        courseChunks.courseInstances[courseInstanceId] = {
                            assessments: new Set(),
                            clientFilesCourseInstance: false,
                        };
                    }
                    courseChunks.courseInstances[courseInstanceId].assessments.add(assessmentId);
                }
            }
        }
    });

    return courseChunks;
};

/**
 * Returns all the chunks the are currently stored for the given course.
 * 
 * @param {string} courseId 
 */
module.exports.getAllChunksForCourse = async (courseId) => {
    const result = await sqlDb.queryAsync(sql.select_course_chunks, { course_id: courseId });
    return result.rows;
};

/**
 * Given a course ID, computes a list of all chunks that need to be
 * (re)generated.
 */
module.exports.identifyChunksToGenerate = async (courseId) => {
    const rawCourseChunks = await module.exports.getAllChunksForCourse(courseId);

    // Build a data structure from the result of getAllChunksForCourse so that
    // we can efficiently query to see if a given chunk exists
    /** @type {CourseChunks} */
    const courseChunks = {
        elements: false,
        serverFilesCourse: false,
        clientFilesCourse: false,
        courseInstances: {},
        questions: new Set(),
    };

    rawCourseChunks.forEach(courseChunk => {
        switch (courseChunk.type) {
            case 'elements':
            case 'serverFilesCourse':
            case 'clientFilesCourse':
                courseChunks[courseChunk.type] = true;
                break;
            case 'question':
                courseChunks.questions.add(courseChunk.question_name);
                break;
            case 'clientFilesCourseInstance': {
                const courseInstanceName = courseChunk.course_instance_name;
                if (!courseChunks.courseInstances[courseInstanceName]) {
                    courseChunks.courseInstances[courseInstanceName] = {
                        assessments: new Set(),
                        clientFilesCourseInstance: true,
                    };
                }
                courseChunks.courseInstances[courseInstanceName].clientFilesCourseInstance = true;
                break;
            }
            case 'clientFilesAssessment': {
                const courseInstanceName = courseChunk.course_instance_name;
                const assessmentName = courseChunk.assessment_name;
                if (!courseChunks.courseInstances[courseInstanceName]) {
                    courseChunks.courseInstances[courseInstanceName] = {
                        assessments: new Set(),
                        clientFilesCourseInstance: false,
                    };
                }
                courseChunks.courseInstances[courseInstanceName].assessments.add(assessmentName);
                break;
            }
        }
    });
};
