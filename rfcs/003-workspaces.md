# Workspaces

# Summary

Run persistent containers for users with web frontends, like VS Code and Jupyter Notebooks.

# Motivation and background

PrairieLearn currently allows code editing using an in-page ACE Editor and can compile and test code via external graders, which take student code and instructor-provided test code and execute them in an instructor-defined container, returning the test results back to the student. While excellent for testing small code snippets, this is not a very flexible environment for writing and debugging more complex programs.

This RFC proposes to give students persistent remote containers (called _Workspaces_) to work in, configured by instructors to provide a per-question environment with a specific set of compilers, debuggers, editors, etc. This remote container would be accessed via a web-based frontend, such as VS Code or Jupyter Notebooks.

Goals:
* Workspaces should be instructor-defined on a per-question basis.
* Workspaces should launch from a PL question with a set of initial files in the home directory, which may be dynamically generated by the question `server.py` code.
    * Workspaces should retain a readonly copy of these initial files to allow the student to reference/restore the initial state.
* The workspace should be accessible by the student via a web frontend (e.g., VS Code) that is served out of the workspace container.
* The student should have complete freedom to use the workspace as a development environment, including compiling and executing code.
* The files in the container home directory should be frequently autosaved to a persistent store, in case of container crashes (e.g., fork bombs).
* At any time, the student should be able to trigger a "Grade" action, which will pull an instructor-defined set of files from the container and run the usual PL grading code (either internal or external graders).
* Workspaces should auto-terminate after a period of inactivity (or force-terminated by the student), but should be able to be re-launched with the persistent home-directory files restored.

# Proposed solution

The server architecture has three conceptual components:
1. Main PL web servers: render questions for the student with a "launch workspace" button in them.
2. Manager servers: coordinate the launching of workspaces and proxy all traffic from the student browser through to the host machines.
3. Host servers: run the actual containers.

These three components are implemented within the main PL executable, but for deployment we can run different fleets of servers that use a `config` option to only turn on specific functionality.

## How this works

* When we want to launch a container, we bundle files, upload to S3, download to worker, spin up a container with files mounted to a known good location.
* Run filesystem watcher on mounted directory.
* When files change, we’ll do two things:
    * We’ll upload the workspace state to S3.
    * We’ll push the submission state into the database (somewhere, tbd) and store errors too?

## Frontend

* We’ll serve the page as two parts:
    * An “outer part” that PrairieLearn controls - this gives us a place to show save status, and potentially show a grade button and immediate feedback in the long run. Can also show “I’ve bricked my container, pls help” button.
    * An “inner part”, which is the page served by the container.

## Workspace container orchestration

* When we create a variant, we (maybe) create an editor session (if it’s enabled for that question). This is at this point just an entry in a database table somewhere.
* We render some kind of button to launch an editor instance for that session.
* The user clicks on that button.
* We get a request for a particular workspace instance.
* We check the authorization cookies to verify that the requesting user matches the authorized user for this workspace.
* Routes:
    * `/workspace/[uuid]` - serves outer frame
    * `/workspace/[uuid]/heartbeat`
    * `/workspace/[uuid]/container/*` - proxy `*` to inner frame
* On the host:
    * `/workspace/[uuid]/workspace/*` goes to the host that’s running this container.
    *  Within the host, we’ll proxy that to the appropriate container.
    *  Each container will probably need port 80 bound to some random, unique port that we can target for forwards.
    * The host will listen for three types of signals: launch, sync, and kill container.
* How to map requests to hosts?
    * Hosts table that stores current information about each host VM.
* How do we kill off old containers?
    * Containers are killed after either:
        * We don’t receive N heartbeats in a row.
        * The user hasn’t saved for X amount of time.

Need to make sure that cookies are inaccessible to client-side code (https://github.com/PrairieLearn/PrairieLearn/issues/2503) and on the server (we need to configure our proxy to strip out at least the Cookie header, if not more things).

## Notes

* There’s a distinction between workspace state and submission state - the former can include arbitrary files, the latter just includes whatever the question specifies.
